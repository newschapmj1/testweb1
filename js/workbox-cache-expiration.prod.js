this.workbox=this.workbox||{},this.workbox.expiration=function(t,s,e,i,a,n){"use strict";try{self.workbox.v["workbox:cache-expiration:4.0.0-beta.0"]=1}catch(t){}const h="url",r="timestamp";class c{constructor(t){this.t=t,this.s=t,this.e=new s.DBWrapper(this.t,2,{onupgradeneeded:t=>this.i(t)})}i(t){const s=t.target.result;t.oldVersion<2&&s.objectStoreNames.contains("workbox-cache-expiration")&&s.deleteObjectStore("workbox-cache-expiration"),s.createObjectStore(this.s,{keyPath:h}).createIndex(r,r,{unique:!1})}async setTimestamp(t,s){await this.e.put(this.s,{[h]:new URL(t,location).href,[r]:s})}async getAllTimestamps(){return await this.e.getAllMatching(this.s,{index:r})}async getTimestamp(t){return(await this.e.get(this.s,t)).timestamp}async deleteUrl(t){await this.e.delete(this.s,new URL(t,location).href)}async delete(){await e.deleteDatabase(this.t),this.e=null}}class o{constructor(t,s={}){this.a=!1,this.n=!1,this.h=s.maxEntries,this.r=s.maxAgeSeconds,this.t=t,this.c=new c(t)}async expireEntries(){if(this.a)return void(this.n=!0);this.a=!0;const t=Date.now(),s=await this.o(t),e=await this.w(),i=[...new Set(s.concat(e))];await Promise.all([this.l(i),this.u(i)]),this.a=!1,this.n&&(this.n=!1,this.expireEntries())}async o(t){if(!this.r)return[];const s=t-1e3*this.r,e=await this.c.getAllTimestamps(),i=[];return e.forEach(t=>{t.timestamp<s&&i.push(t.url)}),i}async w(){const t=[];if(!this.h)return[];const s=await this.c.getAllTimestamps();for(;s.length>this.h;){const e=s.shift();t.push(e.url)}return t}async l(t){const s=await caches.open(this.t);for(const e of t)await s.delete(e)}async u(t){for(const s of t)await this.c.deleteUrl(s)}async updateTimestamp(t){const s=new URL(t,location);s.hash="",await this.c.setTimestamp(s.href,Date.now())}async isURLExpired(t){if(!this.r)throw new i.WorkboxError("expired-test-without-max-age",{methodName:"isURLExpired",paramName:"maxAgeSeconds"});const s=new URL(t,location);return s.hash="",await this.c.getTimestamp(s.href)<Date.now()-1e3*this.r}async delete(){this.n=!1,await this.c.delete()}}return t.CacheExpiration=o,t.Plugin=class{constructor(t={}){this.d=t,this.r=t.maxAgeSeconds,this.m=new Map,t.purgeOnQuotaError&&n.registerQuotaErrorCallback(()=>this.deleteCacheAndMetadata())}p(t){if(t===a.cacheNames.getRuntimeName())throw new i.WorkboxError("expire-custom-caches-only");let s=this.m.get(t);return s||(s=new o(t,this.d),this.m.set(t,s)),s}cachedResponseWillBeUsed({cacheName:t,cachedResponse:s}){if(!s)return null;let e=this.f(s);return this.p(t).expireEntries(),e?s:null}f(t){if(!this.r)return!0;const s=this.x(t);return null===s||s>=Date.now()-1e3*this.r}x(t){if(!t.headers.has("date"))return null;const s=t.headers.get("date"),e=new Date(s).getTime();return isNaN(e)?null:e}async cacheDidUpdate({cacheName:t,request:s}){const e=this.p(t);await e.updateTimestamp(s.url),await e.expireEntries()}async deleteCacheAndMetadata(){for(const[t,s]of this.m)await caches.delete(t),await s.delete();this.m=new Map}},t}({},workbox.core._private,workbox.core._private,workbox.core._private,workbox.core._private,workbox.core);

//# sourceMappingURL=workbox-cache-expiration.prod.js.map
